# 一言サービスコンセプト
### もう二度とすれ違わない

# 誰のどんな課題を解決するのか？
「言った・言わない」の不毛な争いに疲れたことや、思いがすれ違ったことがある恋人・夫婦の  
　関係性の不和、コミュニケーション負債。
# なぜそれを解決したいのか？
自分自身がパートナーとの約束事を忘れてしまっていたり、  
自分にとって些細なことが相手にとっては重要だったというすれ違いで  
パートナーを傷つけてしまったことがあるから。  

# どうやって解決するのか？
約束を忘れないようにリマインドし、それが相手目線で本当にできているのか  
相手目線での評価をすることによって相互の認識の『すれ違い』をなくす。  
約束に対して自分がどれだけ履行できたかを可視化することで  
自己反省を促し約束に対する誠実性を高める。

# 機能要件
・約束事を登録し、一覧として表示(自分と相手、共通の約束の3つ)  
・それぞれの約束事には期限を設定し、期限になったら約束事を自動で削除  
・約束事の編集、削除  
・週に一回、共通の約束事からローテーションで評価をさせるリマインド 
・期日付の約束は期日が来たら評価をさせるリマインド   
・月の終わりに今月の信用スコアの平均と収穫された林檎の個数を自動でメールで送信  
・評価項目は星5段階でつけて、思ったことを記入する欄を設ける
・これまでのお互いの信頼スコアの合計を表示  
・過去の約束事の評価スコアと思ったことの表示（星2以下なら改善案も）  
・ユーザーログイン、プロフィール画像のアップロード  
・限定リンクを発行してパートナーを招待できる機能  
・約束に対する評価が星2以下だったら改善案を記入させるリマインド  
・今週評価される約束事をピックアップして表示  
・約束事の評価に合わせてりんごの木にリンゴが実ったり、枯れて落ちたりするアニメーション  
・デフォルトで共通の約束事を表示  
・月の最後にはりんごを収穫して個数をリセット  
・ふと思ったことや、あの時は言えなかったけど言いたいことを伝えるフォーム  

# 非機能要件定義

## 1. ユーザビリティ

| 項目 | 要件内容 | 具体的な実現方法/技術 |
| :--- | :--- | :--- |
| **パフォーマンス** | 全ての画面で、ユーザーの操作に対する応答が1秒以内であること。 | ・APIのN+1問題を検知・防止 (`bullet` gem)<br>・重い処理は非同期実行 (`Sidekiq`等)<br>・ReactのCode Splitting, Lazy Loading<br>・画像の遅延読み込み |
| **体感速度** | データの更新処理（約束の登録、評価など）が瞬時に画面に反映されること。 | ・Reactで楽観的UI更新（Optimistic UI Updates）を実装し、サーバーからの応答を待たずにUIを先に変更する。 |
| **レスポンシブ** | スマートフォン、タブレット、PCなど、あらゆるデバイスで表示崩れなく、快適に操作できること。 | ・モバイルファーストでのCSS設計。<br>・`Material-UI`や`Chakra UI`などのUIライブラリのグリッドシステムを活用。 |

## 2. 信頼性・可用性

| 項目 | 要件内容 | 具体的な実現方法/技術 |
| :--- | :--- | :--- |
| **障害耐性** | アプリケーションコンテナが何らかの原因で停止した場合、自動で再起動すること。 | ・`docker-compose.yml`にて`restart: always`ポリシーを設定。 |
| **データ保全** | データベースサーバーに障害が発生した場合でも、データを復旧できること。 | ・1日1回の自動バックアップを取得し、別ストレージ（例: AWS S3）に保管する。<br>・リストア手順をドキュメント化し、定期的にテストする。 |
| **エラーハンドリング** | サーバーエラーや通信エラーが発生した際に、ユーザーに分かりやすく状況を伝えること。 | ・サーバー側で500エラーが発生した場合、専用のエラーページを表示。<br>・クライアント側でAPI通信に失敗した場合、「通信に失敗しました」等のトースト/スナックバーを表示する。 |

## 3. 拡張性・保守性

| 項目 | 要件内容 | 具体的な実現方法/技術 |
| :--- | :--- | :--- |
| **コード品質** | 定められたコーディング規約に準拠し、一貫性のあるコードを維持すること。 | ・静的解析ツールをCIに組み込む。<br>  - Rails: `RuboCop`<br>  - TypeScript/React: `ESLint`, `Prettier` |
| **型安全性** | TypeScriptの型システムを活用し、実行時エラーを未然に防ぐ。 | ・`tsconfig.json`で`"strict": true`を設定。<br>・APIのレスポンス/リクエストの型定義を共有する。 |
| **テスト** | 新規機能の追加やリファクタリングによって既存機能が破壊されていないことを保証する。 | ・CI実行時に自動テストを実施する。<br>  - Rails: RSpecによるモデル、リクエストテスト<br>  - React: React Testing Library, Jestによるコンポーネントテスト |
| **コンポーネント設計** | UIコンポーネントが再利用可能で、他の部分への影響が少ないこと。 | ・`Atomic Design`などの設計手法を参考に、コンポーネントの粒度と責務を明確にする。 |

## 4. セキュリティ

| 項目 | 要件内容 | 具体的な実現方法/技術 |
| :--- | :--- | :--- |
| **認証** | ユーザーは自身のアカウント情報でのみログインできること。パスワードは安全に保管されること。 | ・パスワードのハッシュ化 (`bcrypt`)。<br>・API認証にはJWT (JSON Web Token) を使用し、HTTP Only属性のCookieに保存してXSSリスクを低減。 |
| **認可** | ユーザーは自分とパートナーが関わる約束の情報のみ閲覧・編集できること。 | ・Rails API側で、リクエストごとに閲覧・操作権限を厳密にチェックする (`Pundit` gemなど)。 |
| **脆弱性対策** | SQLインジェクション、XSS、CSRF等の既知の脆弱性からアプリケーションを保護する。 | ・Rails, Reactの標準的なセキュリティ機能を有効活用。<br>・依存ライブラリの脆弱性を定期的にスキャン (`Dependabot`, `npm audit`)。 |
| **通信の暗号化** | クライアントとサーバー間の全ての通信が暗号化されていること。 | ・本番環境では常時HTTPS通信を強制する。 |

## 5. イレギュラーケースの考慮

* **ユーザー操作/データ状態**
    * **パートナー未登録/招待中：** パートナーを招待したが、相手がまだアプリに登録していない場合の画面表示を定義する。（例：「〇〇さんが参加するのを待っています…」）
    * **パートナー関係の解消：** 関係を解消する機能を提供する場合、関連する約束や評価データの削除ポリシー（論理削除か物理削除か、相手への通知はどうするか）を定義する。
    * **データが0件の場合：** ユーザー登録直後など、約束や評価が1件もない場合の各画面の表示を定義する。
    * **同時編集：** パートナーと同時に同じ約束を編集しようとした場合の挙動を定義する。（例：後から更新した内容で上書きし、相手には更新された旨を通知する）
* **システム/通信**
    * **メール送信失敗：** 評価通知などのメール送信に失敗した場合のリトライ処理と、開発者へのエラー通知の仕組みを定義する。
    * **オフライン状態：** ユーザーがオフラインの状態で操作しようとした場合の挙動を定義する。（例：「オフラインです。接続を確認してください」と表示）

## 6. 運用・保守・開発体制 

| 項目 | 要件内容 | 具体的な実現方法/技術 |
| :--- | :--- | :--- |
| **デプロイ** | `main`ブランチにマージされたソースコードは、自動でテスト・ビルドされ、本番環境にデプロイされること。 | ・GitHub Actionsを利用したCI/CDパイプラインを構築する。 |
| **エラー監視** | 本番環境で発生した予期せぬエラーは、開発者にリアルタイムで通知されること。 | ・エラー監視サービス (`Sentry`など) を導入し、Slack等に通知を連携する。 |
| **ログ管理** | アプリケーションの動作ログやユーザーのアクセスログを一元的に収集・閲覧できること。 | ・構造化ロギングを導入し、ログ収集サービス (`Datadog`, `CloudWatch Logs`など) に転送する。 |
| **環境変数管理** | DBのパスワードや外部APIキーなどの機密情報を安全に管理すること。 | ・Railsの`credentials`機能や、AWS Secrets Managerなどの専用サービスを利用し、ソースコードには直接記述しない。 |
